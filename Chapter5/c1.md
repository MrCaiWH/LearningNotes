# 时间复杂度

O(n): n就是这个代码需要跑多少次

Array

刚好插入最后一个O(1)。如果插到第一个，那就是O(n)。平均下来就是O(n/2)。

* Access: O(1)
* Insert: 平均 O(n)
* Delete: 平均 O(n)

## 快慢指针

可以判断单链表是否有环

快指针每次走两步，慢指针每次走一步。

可以理解为慢指针不动，快指针每次走一步。那么快指针肯定在一圈之内就能追上慢指针。

为什么快指针每次要走2步？

如果快指针每次走3步的话，那么可以理解为慢指针不动，快指针每次走两步。那么就有可能出现快指针和慢指针就差一步的情况，下一次移动就会越过慢指针，而不会发生相遇。

双端队列

时间复杂度

window下标

假设由于window的移动

Queue

双端队列

前K个元素加入到A队列

一直放在队里里面，保留最大值

哈希函数

哈希碰撞

Set（集合）不允许有重复的元素，实现形式有两种，哈希表或二叉树来实现。

Map

* HashMap
* TreeMap

Set

* HashSet
* TreeSet

哈希表和二叉树

哈希表 查询时间复杂度 O(1)
二叉树 查询时间复杂度log2n

二叉树里面的元素是相对有序排列的，哈希是乱序的

三层嵌套循环

C就等于-(a+b)

ab两层循环，然后在一个set里面查询-(a+b)是否在set里面 O(N)

第一层循环

起点的元素

枚举A

set 暴力查询

1.排序
2.遍历数组，得到a
3.分别拿到a后面的b,和最后一位c
4.a+b+c如果等于0

双向节点

线性表  树  图

每个节点都有两个孩子

二叉搜索树
1.左子树上所有的节点的值均小于它的根节点的值
2.右子树上所有结点的值均大于它的根节点的值

递归函数，向外面传两个值

一个min和一个max

二叉树遍历

* 前序遍历 根-左-右
* 中序遍历 左-根-右
* 后续遍历 左-右-根

    A

 B     C

D  E  F  G

ABDECFG

DBEAFCG

DEBFGCA
